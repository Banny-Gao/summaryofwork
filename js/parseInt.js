//parseInt解析
['1', '2', '3'].map(parseInt) //[1,NAN,NAN]

/**
 * 而parseInt则是用来解析字符串的，使字符串成为指定基数的整数。
parseInt(string, radix)
接收两个参数，第一个表示被处理的值（字符串），第二个表示为解析时的基数。

了解这两个函数后，我们可以模拟一下运行情况

parseInt('1', 0) //radix为0时，且string参数不以“0x”和“0”开头时，按照10为基数处理。这个时候返回1
parseInt('2', 1) //基数为1（1进制）,无法解析，返回NaN
parseInt('3', 2) //基数为2（2进制），解析失败，返回NaN
map函数返回的是一个数组，所以最后结果为[1, NaN, NaN]
 */

// @ts-ignore
parseInt(1 / 0, 19) //18
/**
 * 工作原理是这样的，第一个参数是需要转换的值，第二个参数是转换的进制，比如：二进制，八进制，十进制，十六进制，十八进制等。

对于第一参数，需要有以下注意：
接收的是一个字符串类型的值；
可以传入任意类型的值，比如 function, object …..；
如果不是一个字符串，会先进行隐式转换成一个字符串
对于第二个参数，也需要注意以下几点：

表示转换的进制，或是称作基数，默认是2|8|10|16|18 等等，但貌似 parseInt 函数内部并没有做这样的严格 check，从一方面表明 JS 功能的良好扩展性；
对于这个进制或称为基数，需要注意，由于并没有做 check，所以用户可以输入任意的值；
如果输入的是一个非数字，为直接忽略掉，而使用默认的 10 进制；
如果输入的数字，貌似只有[ 2 - 36] 之间的数字才有效，并不支持 六十 或 六十四 进制；
如果输入的数字是1，则会返回 NaN

Str	Base 21	Base 20	Base 19	Base 10 (decimal)
0	0	0	0	0
1	1	1	1	1
2	2	2	2	2
3	3	3	3	3
4	4	4	4	4
5	5	5	5	5
6	6	6	6	6
7	7	7	7	7
8	8	8	8	8
9	9	9	9	9
a	10	10	10	NaN
b	11	11	11	NaN
c	12	12	12	NaN
d	13	13	13	NaN
e	14	14	14	NaN
f	15	15	15	NaN
g	16	16	16	NaN
h	17	17	17	NaN
i	18	18	18	NaN
j	19	19	NaN	NaN
k	20	NaN	NaN	NaN
l	NaN	NaN	NaN	NaN
m	NaN	NaN	NaN	NaN
--------------------- 
所以本文的第一个例子中，parseInt( 1 / 0, 19)，首先会将第一个参数 1 / 0 转换成字符串 “Infinity”，再将其以 Base 19 转换成数值。

如上Base 数值对应表可见，Base 为 19 可以接受的字符串为 [0-9a-i] (字母不区分大小写)，所以将 i 转换成 18，而其后的 “nfinity” 全部会省略掉，所以最终的结果为 18
--------------------- 
注： parseFloat只接收一个参数
 */